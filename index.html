<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Market Clock</title>
<style>
/* (same CSS as your original, kept concise) */
* { transition: background-color 0.4s ease, color 0.4s ease; }
:root.dark body{ background:#111; color:#fff; }
:root.light body{ background:#f5f5f5; color:#111; }
body{ margin:0; padding:40px; font-family:Arial,Helvetica,sans-serif; text-align:center; }
#pageTitle{ font-size:28px; font-weight:600; margin-bottom:20px; opacity:0.9; }
#timezone{ margin-bottom:30px; font-size:16px; opacity:0.8; }
#themeToggle, #tzToggle{ position:fixed; top:20px; padding:8px 14px; border:none; border-radius:6px; cursor:pointer; font-size:14px; }
#themeToggle{ right:20px; } #tzToggle{ right:140px; }
:root.dark #themeToggle, :root.dark #tzToggle{ background:#444; color:#fff; }
:root.light #themeToggle, :root.light #tzToggle{ background:#ddd; color:#000; }
#top{margin-bottom:40px} #clock{font-size:72px;font-weight:bold} #date{font-size:16px;opacity:.8}
#markets{ max-width:1000px; margin:0 auto; text-align:left; }
.market-grid{ display:grid; grid-template-columns:1fr; gap:24px; }
@media (min-width:900px){ .market-grid{ grid-template-columns:1fr 1fr; column-gap:28px; row-gap:24px; } }
.market { font-size:18px; padding:16px 18px; border-radius:10px; box-shadow:0 2px 6px rgba(0,0,0,0.25); background:rgba(0,0,0,0.1); position:relative; user-select: auto; }
.market.dragging { user-select: none; }:root.dark .market{ background:#1a1a1a; box-shadow:0 2px 10px rgba(0,0,0,0.6); }
:root.dark .open{color:#4caf50} :root.dark .closed{color:#e53935}
:root.light .open{color:#2e7d32} :root.light .closed{color:#c62828}
.timeline{ margin-top:8px; height:22px; border-radius:6px; position:relative; overflow:hidden; }
:root.dark .timeline{background:#333} :root.light .timeline{background:#ddd}
.seg{ position:absolute; top:0; height:100%; transition:filter 0.2s ease; }
.seg:hover{ filter:brightness(1.25); }
.pre{background:#9c27b0} .regular{background:#4caf50} .after{background:#2196f3} .overnight{background:#0d1b3d}
.now{ position:absolute; top:-10px; bottom:-10px; width:4px; background:#ff0000; box-shadow:0 0 6px #ff0000; transition:left 1s linear; }
.now:after{ content:"â–¼"; position:absolute; top:-16px; left:-7px; color:#ff0000; font-size:16px; }
#legend{ margin-top:40px; font-size:16px; } .legend-item{ display:inline-flex; align-items:center; margin:0 12px; }
.legend-box{ width:18px; height:18px; margin-right:6px; border-radius:4px; }
#shareContainer{ margin-top:30px; text-align:center; } #shareBtn{ padding:10px 20px; border:none; border-radius:6px; cursor:pointer; font-size:16px; }
:root.dark #shareBtn{ background:#444; color:#fff; } :root.light #shareBtn{ background:#ddd; color:#000; }
#reorderControls { margin-top: 10px; } #resetOrderBtn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px; }
:root.dark #resetOrderBtn { background: #444; color: #fff; } :root.light #resetOrderBtn { background: #ddd; color: #000; }
#logoContainer { position: fixed; left: 20px; top: 20px; z-index: 100; }
#logo { max-width: 300px; height: auto; display: block; }
#openMarketsSidebar { position: fixed; left: 0; top: 120px; width: 200px; padding: 15px; background: rgba(0,0,0,0.15); backdrop-filter: blur(6px); border-radius: 0 8px 8px 0; font-size: 15px; text-align:left; }
:root.light #openMarketsSidebar { background: rgba(255,255,255,0.6); } #openMarketsSidebar h3 { margin-top: 0; font-size: 17px; }
#openMarketsList, #openingSoonList { list-style: none; padding-left: 0; margin: 0; }
#openMarketsList li, #openingSoonList li { margin-bottom: 6px; }
.market.dragging { opacity: 0.6; transform: scale(1.03); box-shadow: 0 6px 18px rgba(0,0,0,0.35); z-index: 10; }
.market.placeholder { border: 2px dashed #888; background: transparent !important; height: 80px; }
.open-dot { margin-left:6px; font-size:0.95em; vertical-align:middle; }

/* MOBILE / SMALL SCREEN OPTIMIZATIONS */
@media (max-width: 900px) {
  body {
    padding: 12px;
    text-align: left;
  }
  /* Logo adjustments for mobile */
  #logoContainer {
    position: static;
    text-align: center;
    margin-bottom: 12px;
  }
  #logo {
    max-width: 240px;
    margin: 0 auto;
  }
  /* move top buttons into flow so they don't overlap content */
  #themeToggle, #tzToggle {
    position: static;
    display: inline-block;
    margin: 6px 8px;
    right: auto;
    top: auto;
  }
  /* make title and timezone stack compactly */
  #pageTitle { font-size: 20px; margin-top: 8px; }
  #timezone { font-size: 14px; margin-bottom: 10px; }

  /* Sidebar becomes a full-width block above markets */
  #openMarketsSidebar {
    position: static;
    left: auto;
    top: auto;
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  #openMarketsSidebar h3 { margin: 0; font-size: 15px; }
  #openMarketsList, #openingSoonList {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
  #openMarketsList li, #openingSoonList li {
    margin: 0;
    padding: 6px 8px;
    border-radius: 999px;
    font-weight: 600;
    background: rgba(255,255,255,0.03);
    align-items: center;
    display: inline-flex;
    gap: 6px;
  }

  /* markets adjust to single column and tighter spacing */
  .market-grid {
    grid-template-columns: 1fr !important;
    gap: 12px;
  }
  .market {
    font-size: 16px;
    padding: 12px;
    border-radius: 8px;
  }
  .timeline { height: 28px; }

  /* reduce clock size */
  #clock { font-size: 36px; }
  #date { font-size: 13px; }

  /* legend and large controls moved to compact layout */
  #legend { display: none; }
  #shareContainer, #reorderControls { display: flex; gap: 8px; flex-wrap: wrap; justify-content: stretch; }
  #shareBtn, #resetOrderBtn { flex: 1; }

  /* ensure placeholder and dragging layers behave nicely */
  .market.dragging { position: fixed; left: 0; right: 0; margin: 0 auto; width: calc(100% - 24px); }
  .market.placeholder { height: 72px; }

  /* ensure the markets container has proper padding on small screens */
  #markets { padding-top: 6px; }

  /* avoid fixed overlapping on very small screens */
  @media (max-width: 420px) {
    #themeToggle, #tzToggle { font-size: 13px; padding: 6px 10px; }
    #clock { font-size: 28px; }
    body { padding: 10px; }
  }
}
</style>
</head>
<body>
<button id="themeToggle">Dark</button>
<button id="tzToggle">Show Market Local Times</button>

<div id="pageTitle">Market Clock â€“ Live Global Market Open/Close Times</div>
<div id="timezone"></div>

<div id="top">
  <div id="clock"></div>
  <div id="date"></div>
</div>

<!-- LOGO -->
<div id="logoContainer">
  <img src="Market.png" alt="Logo" id="logo">
</div>

<!-- LEFT SIDEBAR -->
<div id="openMarketsSidebar">
  <h3>Open Markets</h3>
  <ul id="openMarketsList"></ul>
  <h3>Opening Soon</h3>
<ul id="openingSoonList"></ul>
</div>

<!-- Markets container -->
<div id="markets" class="market-grid"></div>

<div id="legend">
  <div class="legend-item"><div class="legend-box" style="background:#9c27b0"></div>Preâ€‘Market</div>
  <div class="legend-item"><div class="legend-box" style="background:#4caf50"></div>Regular Hours</div>
  <div class="legend-item"><div class="legend-box" style="background:#2196f3"></div>After Hours</div>
  <div class="legend-item"><div class="legend-box" style="background:#0d1b3d"></div>Overnight</div>
</div>

<div id="shareContainer">
  <button id="shareBtn">Share</button>
</div>

<div id="reorderControls">
  <button id="resetOrderBtn">Reset Order</button>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  /* THEME TOGGLE */
  const root = document.documentElement;
  const toggle = document.getElementById("themeToggle");
  root.classList.add("dark");
  toggle.textContent = "Light";
  toggle.addEventListener("click", () => {
    if (root.classList.contains("dark")) {
      root.classList.remove("dark");
      root.classList.add("light");
      toggle.textContent = "Dark";
    } else {
      root.classList.remove("light");
      root.classList.add("dark");
      toggle.textContent = "Light";
    }
  });

  /* SHARE BUTTON */
  const shareBtn = document.getElementById("shareBtn");
  function fallbackPrompt(url){ alert("Share this link:\n\n" + url); }
  shareBtn.addEventListener("click", () => {
    const url = window.location.href;
    const shareData = { title: "Market Clock", text: "Check out this live global market clock!", url };
    if (navigator.share) { navigator.share(shareData).catch(()=>{}); return; }
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(url).then(()=> {
        const prev = shareBtn.textContent;
        shareBtn.textContent = "Copied!";
        setTimeout(()=> shareBtn.textContent = prev, 1500);
      }).catch(()=> fallbackPrompt(url));
    } else { fallbackPrompt(url); }
  });

  /* TIME HELPERS */
  function utcSec(){
    const d=new Date();
    return d.getUTCHours()*3600 + d.getUTCMinutes()*60 + d.getUTCSeconds();
  }
  function pct(x){ return (x/86400)*100; }
  function format(sec){ sec=Math.max(0,Math.floor(sec)); return Math.floor(sec/3600)+"h "+Math.floor((sec%3600)/60)+"m "+(sec%60)+"s"; }
  function inRange(t,a,b){ if(b>a) return t>=a && t<b; return t>=a || t<b; }
  function secsToHMS(sec){
    sec = Math.floor(sec);
    const h = Math.floor(sec/3600);
    const m = Math.floor((sec%3600)/60);
    const s = sec%60;
    return {h,m,s};
  }

  /* MARKETS */
  const markets = [
  { id:"nyse", name:"New York (NYSE & NASDAQ)", tz:"America/New_York", pre: 13*3600, open: 14.5*3600, close: 21*3600, after: 22*3600, localOpen: "09:30", localClose: "16:00" },
  { id:"lse", name:"London (LSE)", tz:"Europe/London", open: 8*3600, close: 16.5*3600, localOpen: "08:00", localClose: "16:30" },
  { id:"xetra", name:"Frankfurt (Xetra)", tz:"Europe/Berlin", open: 8*3600, close: 17.5*3600, localOpen: "09:00", localClose: "17:30" },
  { id:"paris", name:"Euronext Paris", tz:"Europe/Paris", open: 8*3600, close: 17.5*3600, localOpen: "09:00", localClose: "17:30" },
  { id:"tse", name:"Tokyo (TSE)", tz:"Asia/Tokyo", open1: 0*3600, close1: 11.5*3600, open2: 12.5*3600, close2: 15*3600, localOpen1: "09:00", localClose1: "11:30", localOpen2: "12:30", localClose2: "15:00" },
  { id:"hkex", name:"Hong Kong (HKEX)", tz:"Asia/Hong_Kong", open1: 1*3600, close1: 4*3600, open2: 5*3600, close2: 8*3600, localOpen1: "09:30", localClose1: "12:00", localOpen2: "13:00", localClose2: "16:00" },
  { id:"sse", name:"Shanghai (SSE)", tz:"Asia/Shanghai", open1: 1.5*3600, close1: 3.5*3600, open2: 5*3600, close2: 7*3600, localOpen1: "09:30", localClose1: "11:30", localOpen2: "13:00", localClose2: "15:00" },
  { id:"sgx", name:"Singapore (SGX)", tz:"Asia/Singapore", open: 1*3600, close: 9*3600, localOpen: "09:00", localClose: "17:00" },
  { id:"nse", name:"India (NSE)", tz:"Asia/Kolkata", open: 3.5*3600, close: 10*3600, localOpen: "09:15", localClose: "15:30" },
  { id:"asx", name:"Sydney (ASX)", tz:"Australia/Sydney", open: 23.983*3600, close: 5*3600, localOpen: "09:59", localClose: "16:00" },
  { id:"tsx", name:"Toronto (TSX)", tz:"America/Toronto", open: 14.5*3600, close: 21*3600, localOpen: "09:30", localClose: "16:00" },
  { id:"b3", name:"Brazil (B3)", tz:"America/Sao_Paulo", open: 12*3600, close: 17.917*3600, localOpen: "10:00", localClose: "17:55" }
];

  /* TIMEZONE TOGGLE */
  let showLocalMarketTime = false;
  const tzToggle = document.getElementById("tzToggle");
  tzToggle.addEventListener("click", () => {
    showLocalMarketTime = !showLocalMarketTime;
    tzToggle.textContent = showLocalMarketTime ? "Show Your Timezone" : "Show Market Local Times";
    updateMarkets();
  });

  /* STAGE LOGIC */
  function getStage(now, m) {
    if (m.pre !== undefined) {
      if (inRange(now, m.pre, m.open)) return "Preâ€‘Market";
      if (inRange(now, m.open, m.close)) return "Regular Hours";
      if (inRange(now, m.close, m.after)) return "After Hours";
      return "Overnight";
    }
    if (m.open1 !== undefined) {
      if (inRange(now, m.open1, m.close1)) return "Morning Session";
      if (inRange(now, m.close1, m.open2)) return "Lunch Break";
      if (inRange(now, m.open2, m.close2)) return "Afternoon Session";
      return "Overnight";
    }
    if (inRange(now, m.open, m.close)) return "Regular Hours";
    return "Overnight";
  }

  /* TIMELINE */
  function drawSeg(a,b,cls){
    if(b>a){
      return `<div class="seg ${cls}" style="left:${pct(a)}%;width:${pct(b-a)}%"></div>`;
    }else{
      return `<div class="seg ${cls}" style="left:${pct(a)}%;width:${pct(86400-a)}%"></div>
              <div class="seg ${cls}" style="left:0;width:${pct(b)}%"></div>`;
    }
  }
  function drawTimeline(m) {
    let html = "";
    if (m.pre !== undefined) {
      html += drawSeg(m.pre, m.open, "pre");
      html += drawSeg(m.open, m.close, "regular");
      html += drawSeg(m.close, m.after, "after");
      html += drawSeg(m.after, m.pre, "overnight");
      return html;
    }
    if (m.open1 !== undefined) {
      html += drawSeg(m.open1, m.close1, "regular");
      html += drawSeg(m.close1, m.open2, "overnight");
      html += drawSeg(m.open2, m.close2, "regular");
      html += drawSeg(m.close2, m.open1, "overnight");
      return html;
    }
    html += drawSeg(m.open, m.close, "regular");
    html += drawSeg(m.close, m.open, "overnight");
    return html;
  }

  /* COUNTDOWN */
  function nextEvent(now, m) {
    const add = t => (t - now + 86400) % 86400;
    if (m.pre !== undefined) {
      if (inRange(now, m.pre, m.open)) return ["Opens in", add(m.open)];
      if (inRange(now, m.open, m.close)) return ["Closes in", add(m.close)];
      if (inRange(now, m.close, m.after)) return ["Afterâ€‘hours ends in", add(m.after)];
      return m.id === "nyse" ? ["Opens in", add(m.open)] : ["Opens in", add(m.pre)];
    }
    if (m.open1 !== undefined) {
      if (inRange(now, m.open1, m.close1)) return ["Closes in", add(m.close1)];
      if (inRange(now, m.close1, m.open2)) return ["Reopens in", add(m.open2)];
      if (inRange(now, m.open2, m.close2)) return ["Closes in", add(m.close2)];
      return ["Opens in", add(m.open1)];
    }
    if (inRange(now, m.open, m.close)) return ["Closes in", add(m.close)];
    return ["Opens in", add(m.open)];
  }

  /* INITIAL RENDER */
  const marketsContainer = document.getElementById("markets");
  markets.forEach(m => {
    const wrapper = document.createElement("div");
    wrapper.className = "market closed";
    wrapper.id = `market-${m.id}`;
    wrapper.innerHTML = `
      <div class="market-header">
        <strong class="market-name">${m.name}</strong>:
        <span class="market-status">CLOSED</span> â€”
        <span class="market-countdown-label">Opens in</span>
        <span class="market-countdown">--</span>
      </div>
      <em class="market-stage">Stage: --</em>
      <div class="timeline">
        ${drawTimeline(m)}
        <div class="now"></div>
      </div>
    `;
    marketsContainer.appendChild(wrapper);
  });

       /* TRELLOâ€‘STYLE DRAG & DROP with HOLD-TO-DRAG on touch */
  let draggedEl = null;
  let placeholder = null;
  let offsetX = 0;
  let offsetY = 0;
  let holdTimer = null;
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;
  let moveListenerAdded = false;

  function enableDragAndDrop() {
    document.querySelectorAll(".market").forEach(card => {
      card.style.touchAction = "pan-y";
      card.style.cursor = "grab";
      card.addEventListener("pointerdown", onPointerDown);
    });
  }

  function onPointerDown(e) {
    if (isDragging) return; // ignore if already dragging
    const card = e.currentTarget;
    lastX = e.clientX;
    lastY = e.clientY;
    const isTouch = e.pointerType === "touch";
    const holdDelay = isTouch ? 450 : 0;

    clearTimeout(holdTimer);
    if (holdDelay === 0) {
      // Desktop: start drag immediately
      startDrag(card);
    } else {
      // Touch: wait for hold
      holdTimer = setTimeout(() => startDrag(card), holdDelay);
    }

    // Add move/up listeners only once
    if (!moveListenerAdded) {
      moveListenerAdded = true;
      document.addEventListener("pointermove", onPointerMove, { passive: false });
      document.addEventListener("pointerup", onPointerUp);
      document.addEventListener("pointercancel", onPointerUp);
    }
  }

  function startDrag(card) {
    if (isDragging) return;
    draggedEl = card;
    isDragging = true;
    draggedEl.classList.add("dragging");
    draggedEl.style.cursor = "grabbing";

    const rect = draggedEl.getBoundingClientRect();
    offsetX = lastX - rect.left;
    offsetY = lastY - rect.top;

    placeholder = document.createElement("div");
    placeholder.className = "market placeholder";
    placeholder.style.height = rect.height + "px";
    draggedEl.parentNode.insertBefore(placeholder, draggedEl.nextSibling);

    draggedEl.style.position = "fixed";
    draggedEl.style.zIndex = 10000;
    draggedEl.style.width = rect.width + "px";
    draggedEl.style.pointerEvents = "none";
    document.body.style.userSelect = "none";

    moveDragged(lastX, lastY);
  }

  function moveDragged(x, y) {
    if (!draggedEl) return;
    draggedEl.style.left = (x - offsetX) + "px";
    draggedEl.style.top = (y - offsetY) + "px";
  }

  function onPointerMove(e) {
    if (holdTimer !== null) {
      // Still waiting for hold to triggerâ€”check if user moved too far
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      if (Math.sqrt(dx * dx + dy * dy) > 8) {
        clearTimeout(holdTimer);
        holdTimer = null;
      }
      return;
    }

    if (!isDragging || !draggedEl) return;

    // Prevent text selection during drag
    e.preventDefault();

    lastX = e.clientX;
    lastY = e.clientY;
    moveDragged(lastX, lastY);

    draggedEl.style.visibility = "hidden";
    const elBelow = document.elementFromPoint(e.clientX, e.clientY);
    draggedEl.style.visibility = "";

    const target = elBelow ? elBelow.closest(".market") : null;

    if (target && !target.classList.contains("dragging") && target.parentNode) {
      const rect = target.getBoundingClientRect();
      const midY = rect.top + rect.height / 2;
      if (e.clientY < midY) {
        target.parentNode.insertBefore(placeholder, target);
      } else {
        target.parentNode.insertBefore(placeholder, target.nextSibling);
      }
    } else {
      const container = document.getElementById("markets");
      if (container && container !== placeholder.parentNode) {
        container.appendChild(placeholder);
      } else if (!placeholder.parentNode) {
        container.appendChild(placeholder);
      }
    }
  }

  function onPointerUp() {
    clearTimeout(holdTimer);
    holdTimer = null;

    if (!isDragging || !draggedEl) {
      moveListenerAdded = false;
      document.removeEventListener("pointermove", onPointerMove);
      document.removeEventListener("pointerup", onPointerUp);
      document.removeEventListener("pointercancel", onPointerUp);
      return;
    }

    draggedEl.classList.remove("dragging");
    draggedEl.style.cursor = "grab";
    draggedEl.style.position = "";
    draggedEl.style.left = "";
    draggedEl.style.top = "";
    draggedEl.style.width = "";
    draggedEl.style.zIndex = "";
    draggedEl.style.pointerEvents = "";
    document.body.style.userSelect = "";

    if (placeholder && placeholder.parentNode) {
      placeholder.parentNode.insertBefore(draggedEl, placeholder);
      placeholder.remove();
    }

    placeholder = null;
    saveOrder();
    draggedEl = null;
    isDragging = false;
    moveListenerAdded = false;
    document.removeEventListener("pointermove", onPointerMove);
    document.removeEventListener("pointerup", onPointerUp);
    document.removeEventListener("pointercancel", onPointerUp);
  }
  function saveOrder() {
    const ids = [...document.querySelectorAll(".market")].map(el => el.id);
    localStorage.setItem("marketOrder", JSON.stringify(ids));
  }

  function loadOrder() {
    try {
      const saved = JSON.parse(localStorage.getItem("marketOrder") || "[]");
      if (!saved.length) return;
      const container = document.getElementById("markets");
      saved.forEach(id => {
        const el = document.getElementById(id);
        if (el) container.appendChild(el);
      });
    } catch (e) {}
  }

  document.getElementById("resetOrderBtn").addEventListener("click", () => {
    localStorage.removeItem("marketOrder");
    const container = document.getElementById("markets");
    container.innerHTML = "";
    markets.forEach(m => {
      const wrapper = document.getElementById(`market-${m.id}`);
      if (wrapper) container.appendChild(wrapper);
    });
    enableDragAndDrop();
  });

  /* UPDATE LOOP */
  function updateMarkets(){
    const now = utcSec();
    const day = new Date().getUTCDay();
    const isWeekend = (day === 0 || day === 6);
    const openList = document.getElementById("openMarketsList");
    openList.innerHTML = "";
    const openingSoonList = document.getElementById("openingSoonList");
openingSoonList.innerHTML = "";
    markets.forEach(m => {
      const el = document.getElementById(`market-${m.id}`);
      const statusEl = el.querySelector(".market-status");
      const countdownEl = el.querySelector(".market-countdown");
      const countdownLabelEl = el.querySelector(".market-countdown-label");
      const stageEl = el.querySelector(".market-stage");
      const nowLine = el.querySelector(".now");
      
      let stage, label, secs;
      
      if (isWeekend) {
        // On weekends, show as closed and calculate time until Monday opening
        stage = "Closed (Weekend)";
        const daysUntilMonday = day === 0 ? 1 : 2; // Sunday=1 day, Saturday=2 days
        const openTime = m.open1 !== undefined ? m.open1 : m.open;
        // Calculate: (days until Monday * seconds per day) - current time + opening time
        const secsToOpen = (daysUntilMonday * 86400) - now + openTime;
        label = "Opens in";
        secs = secsToOpen;
      } else {
        stage = getStage(now, m);
        [label, secs] = nextEvent(now, m);
      }
      
      if (label === "Opens in" && secs > 0 && secs <= 3600 && !isWeekend) {
        const soonLi = document.createElement("li");
        soonLi.textContent = el.querySelector(".market-name").textContent + " â€” " + format(secs);
        openingSoonList.appendChild(soonLi);
      }
      let isOpen = false;
      if (!isWeekend) {
        if (m.pre !== undefined) {
          isOpen = inRange(now, m.open, m.close);
        } else if (m.open1 !== undefined) {
          isOpen = inRange(now, m.open1, m.close1) || inRange(now, m.open2, m.close2);
        } else {
          isOpen = inRange(now, m.open, m.close);
        }
      }
      el.classList.toggle("open", isOpen);
      el.classList.toggle("closed", !isOpen);
      statusEl.textContent = isOpen ? "OPEN" : "CLOSED";
      countdownLabelEl.textContent = label;
      countdownEl.textContent = format(secs);

      if (showLocalMarketTime && m.tz) {
        if (m.open1 !== undefined) {
          stageEl.textContent = `Stage: ${stage} (Local: ${m.localOpen1}â€“${m.localClose1}, ${m.localOpen2}â€“${m.localClose2})`;
        } else if (m.localOpen !== undefined) {
          stageEl.textContent = `Stage: ${stage} (Local: ${m.localOpen}â€“${m.localClose})`;
        } else {
          stageEl.textContent = `Stage: ${stage}`;
        }
      } else {
        stageEl.textContent = "Stage: " + stage;
      }

      nowLine.style.left = pct(now) + "%";
      if (isOpen) {
        const li = document.createElement("li");
        const name = el.querySelector(".market-name").textContent;
        li.innerHTML = name + ' <span class="open-dot" aria-hidden="true">ðŸŸ¢</span>';
        openList.appendChild(li);
      }
    });
  }

  function updateTop(){
    const d=new Date();
    document.getElementById("clock").textContent=d.toLocaleTimeString();
    document.getElementById("date").textContent=d.toDateString();
    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    document.getElementById("timezone").textContent = "Your Timezone: " + tz;
  }

  loadOrder();
  enableDragAndDrop();
  updateTop();
  updateMarkets();
  setInterval(()=>{ updateTop(); updateMarkets(); },1000);
});
</script>
</body>
</html>
